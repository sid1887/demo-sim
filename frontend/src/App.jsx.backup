import React, { useState, useCallback, useEffect } from 'react'
import { motion } from 'framer-motion'

// Import ReactFlow CSS
import 'reactflow/dist/style.css'

// Import new components
import TopToolbar from './components/TopToolbar'
import Sidebar from './components/Sidebar'
import Canvas from './components/Canvas'
import ChatPanel from './components/ChatPanel'
import ResultsViewer from './components/ResultsViewer'
import ImageUploadPanel from './components/ImageUploadPanel'
import NotificationSystem, { notify, simulationNotify, circuitNotify } from './components/NotificationSystem'
import Oscilloscope from './components/Oscilloscope'
import { AdjustableResistor, AdjustableCapacitor, AdjustableInductor, AdjustableVoltageSource } from './components/AdjustableComponents'
// Temporarily comment out signal generators to test
// import { ACVoltageSource, DCVoltageSource, FunctionGenerator, CurrentSourceGen, PulseGenerator, AWG } from './components/SignalGenerators'

// Import utilities and APIs
import { generateNetlist, validateNetlist, EXAMPLE_CIRCUITS } from './utils/netlistGenerator'
import { simulationAPI, geminiAPI, apiUtils } from './api/geminiClient'
import { useKeyboardShortcuts, ShortcutsHelp } from './hooks/useKeyboardShortcuts.jsx'
import { defaultGrid, defaultPinSystem } from './utils/gridSystem'

// Import styles
import './styles/professional.css'
import './styles/ieee-components.css'
import './styles/pcb-board.css'
import './App.css'

export default function App() {
  const [nodes, setNodes] = useState([])
  const [edges, setEdges] = useState([])
  const [simulationResults, setSimulationResults] = useState(null)
  const [selectedTool, setSelectedTool] = useState('select')
  const [selectedNode, setSelectedNode] = useState(null)
  const [isSimulating, setIsSimulating] = useState(false)
  const [chatOpen, setChatOpen] = useState(false) // Start closed for cleaner UI
  const [imageUploadOpen, setImageUploadOpen] = useState(false)
  const [isAnalyzingImage, setIsAnalyzingImage] = useState(false)
  const [apiStatus, setApiStatus] = useState('checking')
  const [componentStats, setComponentStats] = useState({ count: 0, connections: 0, nodes: 0 })
  const [showShortcutsHelp, setShowShortcutsHelp] = useState(false)
  const [snapToGrid, setSnapToGrid] = useState(true)
  const [panMode, setPanMode] = useState(false)
  const [showOscilloscope, setShowOscilloscope] = useState(false)

  // Check API availability on startup
  useEffect(() => {
    checkAPIStatus()
  }, [])

  // Keyboard shortcuts
  useKeyboardShortcuts({
    onSelect: () => setSelectedTool('select'),
    onWire: () => setSelectedTool('wire'),
    onResistor: () => handleAddComponent('resistor'),
    onCapacitor: () => handleAddComponent('capacitor'),
    onInductor: () => handleAddComponent('inductor'),
    onDiode: () => handleAddComponent('diode'),
    onGround: () => handleAddComponent('ground'),
    onSimulate: () => handleSimulation(),
    onHelp: () => setShowShortcutsHelp(true),
    onPanToggle: () => setPanMode(prev => !prev),
    onAltHold: (isHeld) => setSnapToGrid(!isHeld),
    onSave: () => notify.info('Save functionality coming soon'),
    onUndo: () => notify.info('Undo functionality coming soon'),
    onRedo: () => notify.info('Redo functionality coming soon')
  })

  // Update component stats when nodes/edges change
  useEffect(() => {
    const nodeSet = new Set()
    edges.forEach(edge => {
      nodeSet.add(edge.source)
      nodeSet.add(edge.target)
    })

    setComponentStats({
      count: nodes.length,
      connections: edges.length,
      nodes: nodeSet.size
    })
  }, [nodes, edges])

  const checkAPIStatus = async () => {
    try {
      const available = await apiUtils.isAPIAvailable()
      setApiStatus(available ? 'available' : 'unavailable')
      if (!available) {
        toast.error('Backend server is not available')
      }
    } catch (error) {
      setApiStatus('unavailable')
      console.error('API Status Check Error:', error)
    }
  }

  // Handle simulation
  const handleSimulation = useCallback(async (circuitNodes, circuitEdges) => {
    try {
      setIsSimulating(true)
      simulationNotify.started()
      
      // Use provided nodes/edges or current state
      const nodesToUse = circuitNodes || nodes
      const edgesToUse = circuitEdges || edges
      
      console.log('üî¨ Starting simulation with:', { 
        nodeCount: nodesToUse.length, 
        edgeCount: edgesToUse.length 
      })
      
      // Validate circuit
      const validation = validateNetlist(nodesToUse, edgesToUse)
      if (validation.errors.length > 0) {
        throw new Error(validation.errors.join(', '))
      }
      
      // Show warnings
      validation.warnings.forEach(warning => {
        simulationNotify.warning(warning)
      })

      // Generate netlist
      const netlist = generateNetlist(nodesToUse, edgesToUse)
      console.log('üìã Generated netlist:\n', netlist)

      // Run simulation using both servers with fallback
      let results
      try {
        // Try Node.js server first (enhanced NgSpice simulation)
        console.log('üî¨ Trying Node.js simulation server...')
        results = await simulationAPI.runSimulation(netlist, 'op')
        
        // Handle Node.js server response format
        if (results.results) {
          setSimulationResults(results.results)
          const nodeCount = Object.keys(results.results.nodes || {}).length
          simulationNotify.success(nodeCount, results.processingTime || 'N/A')
        } else {
          // Direct results format
          setSimulationResults(results)
          const nodeCount = Object.keys(results.nodes || {}).length
          simulationNotify.success(nodeCount, 'N/A')
        }
      } catch (nodeError) {
        console.warn('Node.js server failed, trying Python backend...', nodeError.message)
        
        // Fallback to Python backend
        const { simulate } = await import('./api')
        results = await simulate(netlist, { type: 'dc' })
        setSimulationResults(results.results || results)
        
        const nodeCount = Object.keys((results.results || results).nodes || {}).length
        notify.success(`‚úÖ Simulation completed (Python backend)! Found ${nodeCount} node voltages`)
      }
      
    } catch (error) {
      console.error('Simulation error:', error)
      const errorInfo = apiUtils.formatSimulationError(error)
      simulationNotify.error(`${errorInfo.title}: ${errorInfo.message}`)
      
      if (errorInfo.suggestion) {
        setTimeout(() => {
          notify.info(errorInfo.suggestion, { duration: 5000 })
        }, 1000)
      }
    } finally {
      setIsSimulating(false)
    }
  }, [nodes, edges])

  // Handle component addition from sidebar
  const handleAddComponent = useCallback((type, nodeData) => {
    if (nodeData) {
      setNodes(prev => [...prev, nodeData])
    }
    circuitNotify.componentAdded(type)
  }, [])

  // Handle component value changes
  const handleComponentValueChange = useCallback((componentId, newValue) => {
    setNodes(prev => prev.map(node => 
      node.id === componentId 
        ? { ...node, data: { ...node.data, value: newValue } }
        : node
    ))
    notify.info(`Updated ${componentId} to ${newValue}`)
  }, [])

  // Load example circuit
  const loadExampleCircuit = useCallback((exampleKey) => {
    const example = EXAMPLE_CIRCUITS[exampleKey]
    if (example) {
      setNodes(example.nodes)
      setEdges(example.edges)
      circuitNotify.exampleLoaded(example.name)
    }
  }, [])

  // Clear canvas
  const handleClearCanvas = useCallback(() => {
    setNodes([])
    setEdges([])
    setSimulationResults(null)
    setSelectedNode(null)
    circuitNotify.circuitCleared()
  }, [])

  // Handle oscilloscope toggle
  const handleOscilloscopeToggle = useCallback(() => {
    setShowOscilloscope(prev => !prev)
    if (!showOscilloscope && simulationResults) {
      notify.info('üìä Opening oscilloscope with simulation data')
    }
  }, [showOscilloscope, simulationResults])
  const handleImageAnalyzed = useCallback((analysisResult) => {
    setIsAnalyzingImage(false)
    
    if (analysisResult.error) {
      toast.error(`Image analysis failed: ${analysisResult.error}`)
      return
    }

    const components = analysisResult.components || []
    toast.success(`Circuit analyzed! Found ${components.length} components`)

    // Convert analyzed components to nodes
    const newNodes = components.map((comp, index) => {
      const position = comp.position || [100 + index * 80, 100 + Math.floor(index / 4) * 80]
      
      return {
        id: comp.name || `comp_${index}`,
        type: 'basic-component',
        position: { x: position[0], y: position[1] },
        data: {
          label: comp.name || `${comp.type}_${index}`,
          componentType: comp.type,
          value: comp.value || '1',
          confidence: comp.confidence || 0.8,
          detectionMethod: comp.detection_method || 'ai'
        }
      }
    })

    // Add nodes to canvas
    setNodes(prev => [...prev, ...newNodes])
    
    // Show analysis summary
    const analysis = analysisResult.analysis || {}
    toast(
      `Analysis complete!\n${analysis.detection_quality || 'medium'} quality detection\nProcessing: ${analysisResult.processing_method || 'integrated_yolo_ai'}`,
      { 
        icon: 'üîç', 
        duration: 5000,
        style: { maxWidth: '300px' }
      }
    )
  }, [])

  return (
    <div className="h-screen bg-gray-50 flex flex-col overflow-hidden">
      <Toaster 
        position="top-right"
        toastOptions={{
          duration: 3000,
          style: {
            background: '#ffffff',
            color: '#374151',
            border: '1px solid #d1d5db',
            boxShadow: '0 4px 6px -1px rgba(0, 0, 0, 0.1)',
          },
          success: {
            iconTheme: {
              primary: '#22c55e',
              secondary: '#ffffff'
            }
          },
          error: {
            iconTheme: {
              primary: '#ef4444',
              secondary: '#ffffff'
            }
          }
        }}
      />

      {/* Top Toolbar */}
      <TopToolbar 
        onSimulate={() => handleSimulation()}
        onReset={handleClearCanvas}
        isSimulating={isSimulating}
        onSave={() => notify.info('Save functionality coming soon')}
        onOpen={() => notify.info('Open functionality coming soon')}
        onToggleImageUpload={() => setImageUploadOpen(prev => !prev)}
        onToggleOscilloscope={handleOscilloscopeToggle}
        showOscilloscope={showOscilloscope}
      />

      {/* Main Content */}
      <div className="flex flex-1 overflow-hidden">
        {/* Sidebar - Component Library */}
        <Sidebar 
          onAddComponent={handleAddComponent}
          selectedTool={selectedTool}
          onToolSelect={setSelectedTool}
          componentStats={componentStats}
        />

        {/* Canvas Area */}
        <div className="flex-1 flex flex-col">
          <Canvas
            onSimulate={handleSimulation}
            simulationResults={simulationResults?.results}
            onNodeSelect={handleNodeSelect}
            selectedNodeId={selectedNode?.id}
            onAddComponent={handleAddComponent}
          />

          {/* Bottom Results Panel */}
          {simulationResults && (
            <motion.div
              initial={{ y: 200, opacity: 0 }}
              animate={{ y: 0, opacity: 1 }}
              className="h-64 results-panel border-t"
            >
              <div className="results-panel-header">
                <h3 className="text-sm font-semibold text-gray-700">Simulation Results</h3>
                <div className={`simulation-status ${simulationResults?.success ? 'success' : 'error'}`}>
                  {simulationResults?.success ? 'Success' : 'Error'}
                </div>
              </div>
              <div className="results-panel-content">
                <ResultsViewer 
                  results={simulationResults}
                  nodes={nodes}
                  edges={edges}
                />
              </div>
            </motion.div>
          )}
        </div>

        {/* Chat Panel */}
        {chatOpen && (
          <motion.div
            initial={{ x: 300, opacity: 0 }}
            animate={{ x: 0, opacity: 1 }}
            exit={{ x: 300, opacity: 0 }}
            transition={{ duration: 0.3 }}
            className="w-80 chat-panel"
          >
            <div className="chat-header">
              <h3 className="text-sm font-semibold text-gray-700">AI Assistant</h3>
              <button 
                onClick={() => setChatOpen(false)}
                className="text-gray-400 hover:text-gray-600"
              >
                ‚úï
              </button>
            </div>
            <ChatPanel 
              nodes={nodes}
              edges={edges}
              simulationResults={simulationResults}
              selectedNode={selectedNode}
              onClose={() => setChatOpen(false)}
              apiAvailable={apiStatus === 'available'}
            />
          </motion.div>
        )}

        {/* Image Upload Panel */}
        {imageUploadOpen && (
          <motion.div
            initial={{ x: -300, opacity: 0 }}
            animate={{ x: 0, opacity: 1 }}
            exit={{ x: -300, opacity: 0 }}
            transition={{ duration: 0.3 }}
            className="absolute left-4 top-20 z-50 image-upload-panel-container"
          >
            <ImageUploadPanel
              onImageAnalyzed={handleImageAnalyzed}
              isAnalyzing={isAnalyzingImage}
            />
            <button 
              onClick={() => setImageUploadOpen(false)}
              className="absolute top-2 right-2 text-gray-400 hover:text-gray-600 bg-white rounded-full p-1 shadow-md"
              title="Close image upload"
            >
              ‚úï
            </button>
          </motion.div>
        )}
      </div>

      {/* Chat Toggle Button when closed */}
      {!chatOpen && (
        <button
          onClick={() => setChatOpen(true)}
          className="fixed right-6 bottom-6 z-30 w-12 h-12 bg-blue-500 hover:bg-blue-600 
                   text-white rounded-full shadow-lg transition-all duration-200 
                   flex items-center justify-center"
        >
          üí¨
        </button>
      )}

      {/* Status Bar */}
      <div className="bg-gray-200 border-t border-gray-300 px-4 py-2 text-xs text-gray-600 
                    flex items-center justify-between">
        <div className="flex items-center space-x-4">
          <span>Components: {componentStats.count}</span>
          <span>Connections: {componentStats.connections}</span>
          <span>Nodes: {componentStats.nodes}</span>
        </div>
        <div className="flex items-center space-x-4">
          <div className={`w-2 h-2 rounded-full ${
            apiStatus === 'available' ? 'bg-green-500' : 
            apiStatus === 'unavailable' ? 'bg-red-500' : 'bg-yellow-500'
          }`} />
          <span>
            {apiStatus === 'available' && 'Backend Connected'}
            {apiStatus === 'unavailable' && 'Backend Offline'}
            {apiStatus === 'checking' && 'Checking Connection...'}
          </span>
        </div>
      </div>

      {/* Oscilloscope */}
      <Oscilloscope 
        isOpen={showOscilloscope}
        onClose={() => setShowOscilloscope(false)}
        simulationData={simulationResults}
      />

      {/* Keyboard Shortcuts Help */}
      <ShortcutsHelp 
        isOpen={showShortcutsHelp}
        onClose={() => setShowShortcutsHelp(false)}
      />

      {/* Modern Notification System */}
      <NotificationSystem />
    </div>
  )
}
